// На вход программе подается большое количество целых чисел. Все числа, кроме одного, имеют пару, причем может быть несколько одинаковых пар. Найдите число без пары.

// 1. Программа получет на вход много чисел (сразу?)
// 2. После окончания ввода проанализировать все числа и найти 1, у которого пары нет
// 3. Вывести число без пары.

// 1. Куда писать числа? Предположительно в массив.
// 2. Как определить, что ввод закончен?
// 3. Как вести учет пар? Берем первое число, сравниваем его с каждым числом. Удаляем все
// одинаковые с ним числа
// Если ему нашлась пара, останавливаем поиск и берем второе число. Если дошли до конца
// масcива и последний элемент массива != пара текущему числу, считаем, что текущему
// числу не нашлось пары, возвращаем это число.

package main
import (
	"fmt"
)

func main() {
	var numbers []int = []int{1,1,3,3,4,5,5,4,5,8,9,10,45,28,4,27,6}
	find_pair(0, numbers)
}

func find_pair (begin int, array[]int) bool{
	var cur_num = array[begin]
	array = append(array[:begin], users[begin+1:]...)
	// получили длину массива
	var arr_length int = len(array)
	// получили текущий элемент

	fmt.Println("cur_num = ", cur_num, "\n")
	var j = arr_length - 1

	// fmt.Println("j = ", j, "\n")
	// fmt.Println("begin = ", begin,  "\n")
	// если дошли до канца массива
	if begin == j {
		// возвращаем текущий элемент
		fmt.Println("заключительный иф\n", cur_num)
		//иначе
	}else{
		// сравниваем каждый элемент массива с текущим
		for i := begin; i < arr_length; i++{
			// если числа одинаковые
			if cur_num == array[i] {
				// переходим на новую итерацию рекурсии
				fmt.Println(cur_num,  "= ", array[i],  "\n")
				fmt.Println("числа одинаковые иду на рекурсию\n")
				// begin++
				// begin++
				find_pair (0, array)
				break
				// если числа не одинаковые и при этом мы дошли до конца массива
			}else if cur_num != array[i] && i == (arr_length - 1){
				// возвращаем текущее число
				fmt.Print("не пара, конец массива\n")
				fmt.Println(cur_num)
				break
			}
		}
	}
 return true }
